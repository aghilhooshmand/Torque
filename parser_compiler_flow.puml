@startuml
title Parser and Compiler Data Flow

start

:DSL String\n(e.g., "vote(LR(C=1.0), SVM(kernel='rbf'); voting='soft')");

partition "Parsing Phase" {
    :DSLParser.parse(dsl_string);
    :Tokenize and parse using pyparsing;
    :Create dict-based AST nodes;
    
    note right
        AST Structure:
        {
            "type": "call",
            "name": "vote",
            "pos": [
                {"type": "call", "name": "LR", "kw": {"C": {"type": "literal", "value": 1.0}}},
                {"type": "call", "name": "SVM", "kw": {"kernel": {"type": "literal", "value": "rbf"}}}
            ],
            "kw": {"voting": {"type": "literal", "value": "soft"}}
        }
    end note
}

partition "Compilation Phase" {
    :compile_ast_to_estimator(ast_node);
    
    if (Node type?) then (call)
        if (Node name?) then (model: LR, SVM, RF, DT, NB)
            :build_model(name, kw_nodes);
            :Lookup in MODEL_REGISTRY;
            :eval_value() for each kw arg;
            :safe_kwargs_for() validation;
            :Apply special constraints;
            :Create sklearn model instance;
        else (ensemble: vote, stack, bag, ada)
            :build_* (pos_nodes, kw_nodes);
            :For each base estimator:
            :  Recursively compile;
            :Lookup in ENSEMBLE_REGISTRY;
            :eval_value() for options;
            :safe_kwargs_for() validation;
            :Create sklearn ensemble instance;
        endif
    else (literal)
        :Return literal value;
    endif
}

:sklearn Estimator\n(unfitted, ready to use);

stop

@enduml
